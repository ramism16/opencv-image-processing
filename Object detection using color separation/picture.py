# -*- coding: utf-8 -*-
"""RamisMustafa_224248_DIPLab11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mzul1vb4ktOngYvV9pJ5yzGEMB1hgYr0

    Importing modules (and mounting drive)
"""

import cv2
import numpy as np
#from google.colab.patches import cv2_imshow
print("modules imported")

#from google.colab import drive
#drive.mount('/content/drive')

"""
    Reading the example image (smarties)
"""
#reading the image in color
smarties = cv2.imread("smarties.jpg", cv2.IMREAD_COLOR)

#creating a copy of the image
smartiesCopy = smarties.copy()

#displaying the input image
print("Smarties image\n")

cv2.imshow("Smarties", smarties)
print("Image in the output window")
cv2.waitKey(1500)

#cv2_imshow(smarties)

"""
1: Isolating green smarties from the image

    Converting BGR image to HSV
"""
#converting the image to HSV
smartiesHSV = cv2.cvtColor(smarties, cv2.COLOR_BGR2HSV)

#displaying the converted color space image
print("Smarties HSV image\n")
cv2.imshow("Smarties", smartiesHSV)
print("\nHSV image in the output window\n")
cv2.waitKey(1500)

#printing one of the pixel values from the HSV image
print(smartiesHSV[50][50])
cv2.destroyAllWindows()

"""
    Creating and using trackbars to control HSV channels' limits
"""

#create a named window container for the trackbars first
wname = "HSV Channels Trackbars"
trackbarWindow = cv2.namedWindow(wname)

#create a copy of the HSV image
smartiesHSVCopy = smartiesHSV.copy()

#creating HSV Channels limits varaibles
lowH = highH = lowS = highS = lowV = highV = 0

#creating a switch variable for trackbar toggling
switch = 0

#creating a blank callable function to pass the onChange argument in cv2.inRange()
def dont(x):
    pass

#creating trackbars for channels and switch
#values for the minimum and maximum were based on true HSV values earlier [360,100,100]
#but traded with cv2 8-bit values, because practically changes will be made in reflected in those
cv2.createTrackbar("Low Hue", wname, 0, 255, dont)
cv2.createTrackbar("High Hue",wname, 0, 255, dont)
cv2.createTrackbar("Low Sat", wname, 0, 255, dont)
cv2.createTrackbar("High Sat",wname, 0, 255, dont)
cv2.createTrackbar("Low Value", wname, 0, 255, dont)
cv2.createTrackbar("High Value",wname, 0, 255, dont)
cv2.createTrackbar("Switch 0/1", wname, 0, 1, dont)

print("\nCreating trackbar and image window\n")

#getting and assigning the positions of the four trackbars
while(True):
    #1 ms refresh delay in image frame display and break loop on ESC keyboard interrupt
    #waitkey() & 0XFF returns numlock-state bitwise-separated key input code (for 64-bit machines)
    cv2.imshow("Smarties HSV", smartiesHSVCopy)
    cv2.imshow("Smarties (2)", smartiesCopy)
    key = cv2.waitKey(1) & 0xFF
    if key == 27:
        print("Trackbars interrupted")
        break

    #get trackbar positions for channel limits
    switch = cv2.getTrackbarPos("Switch 0/1", wname)
    lowH = cv2.getTrackbarPos("Low Hue", wname)
    highH = cv2.getTrackbarPos("High Hue", wname)
    lowS = cv2.getTrackbarPos("Low Sat", wname)
    highS = cv2.getTrackbarPos("High Sat", wname)
    lowV = cv2.getTrackbarPos("Low Value", wname)
    highV = cv2.getTrackbarPos("High Value", wname)

    #high and low value arrays
    low = np.array([lowH, lowS, lowV])
    high = np.array([highH, highS, highV])

    #make changes to the image
    #if switched trackbars
    if switch:
        #flags array from cv2.inRange(src, lowerB, upperb)
        #lower[0] <_ src[0] <_ higher[0] and lower[1] ...
        #terminal print bounds when switch is on
        print(low,high)
        #flags from original image as the copy is changed in each iteration
        dstFlags = cv2.inRange(smartiesHSV, low, high)
        #bitwise-and on numpy arrays behaves much the same like logical-and
        smartiesCopy = cv2.bitwise_and(smarties, smarties, mask=dstFlags)

cv2.destroyAllWindows()
